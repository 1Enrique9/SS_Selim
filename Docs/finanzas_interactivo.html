<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Eduardo Selim Martínez Mayorga">
<meta name="dcterms.date" content="2022-05-10">

<title>Finanzas</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="finanzas_interactivo_files/libs/clipboard/clipboard.min.js"></script>
<script src="finanzas_interactivo_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="finanzas_interactivo_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="finanzas_interactivo_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="finanzas_interactivo_files/libs/quarto-html/popper.min.js"></script>
<script src="finanzas_interactivo_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="finanzas_interactivo_files/libs/quarto-html/anchor.min.js"></script>
<link href="finanzas_interactivo_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="finanzas_interactivo_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="finanzas_interactivo_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="finanzas_interactivo_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="finanzas_interactivo_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="finanzas_interactivo_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="finanzas_interactivo_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="finanzas_interactivo_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#finanzas" id="toc-finanzas" class="nav-link active" data-scroll-target="#finanzas">Finanzas</a>
  <ul class="collapse">
  <li><a href="#proyecto-individual" id="toc-proyecto-individual" class="nav-link" data-scroll-target="#proyecto-individual">Proyecto individual</a>
  <ul class="collapse">
  <li><a href="#profesor-eduardo-selim-martínez-mayorga" id="toc-profesor-eduardo-selim-martínez-mayorga" class="nav-link" data-scroll-target="#profesor-eduardo-selim-martínez-mayorga">Profesor: Eduardo Selim Martínez Mayorga</a></li>
  </ul></li>
  <li><a href="#diagrama-de-flujo-del-notebook-quarto" id="toc-diagrama-de-flujo-del-notebook-quarto" class="nav-link" data-scroll-target="#diagrama-de-flujo-del-notebook-quarto">Diagrama de flujo del notebook (Quarto)</a></li>
  </ul></li>
  <li><a href="#librerías" id="toc-librerías" class="nav-link" data-scroll-target="#librerías">Librerías</a></li>
  <li><a href="#descargar-datos-de-yahoo-finance" id="toc-descargar-datos-de-yahoo-finance" class="nav-link" data-scroll-target="#descargar-datos-de-yahoo-finance">Descargar datos de Yahoo Finance</a>
  <ul class="collapse">
  <li><a href="#func-get-close" id="toc-func-get-close" class="nav-link" data-scroll-target="#func-get-close">get_close</a></li>
  <li><a href="#func-returns" id="toc-func-returns" class="nav-link" data-scroll-target="#func-returns">returns_from_close</a></li>
  </ul></li>
  <li><a href="#estimadores" id="toc-estimadores" class="nav-link" data-scroll-target="#estimadores">Estimadores</a>
  <ul class="collapse">
  <li><a href="#func-s0" id="toc-func-s0" class="nav-link" data-scroll-target="#func-s0">ultimo_precio</a></li>
  <li><a href="#func-mu" id="toc-func-mu" class="nav-link" data-scroll-target="#func-mu">calcula_media</a></li>
  <li><a href="#func-sigma" id="toc-func-sigma" class="nav-link" data-scroll-target="#func-sigma">calcula_desv_est</a></li>
  <li><a href="#func-rho" id="toc-func-rho" class="nav-link" data-scroll-target="#func-rho">calcula_correlacion</a></li>
  </ul></li>
  <li><a href="#payoffs-sin-globals" id="toc-payoffs-sin-globals" class="nav-link" data-scroll-target="#payoffs-sin-globals">PAYOFFS (sin globals)</a></li>
  <li><a href="#simulación-gbm-1-activo-con-mu-histórica-p" id="toc-simulación-gbm-1-activo-con-mu-histórica-p" class="nav-link" data-scroll-target="#simulación-gbm-1-activo-con-mu-histórica-p">SIMULACIÓN GBM (1 activo) CON MU HISTÓRICA (P)</a>
  <ul class="collapse">
  <li><a href="#func-sim-single" id="toc-func-sim-single" class="nav-link" data-scroll-target="#func-sim-single">genera_simulaciones_individual</a></li>
  </ul></li>
  <li><a href="#longstaffschwartz-1-activo" id="toc-longstaffschwartz-1-activo" class="nav-link" data-scroll-target="#longstaffschwartz-1-activo">LONGSTAFF–SCHWARTZ (1 activo)</a>
  <ul class="collapse">
  <li><a href="#func-ls-single" id="toc-func-ls-single" class="nav-link" data-scroll-target="#func-ls-single">ejercicio_americana_LS</a></li>
  <li><a href="#func-strategy" id="toc-func-strategy" class="nav-link" data-scroll-target="#func-strategy">obtiene_estrategia_LS</a></li>
  <li><a href="#func-price-single" id="toc-func-price-single" class="nav-link" data-scroll-target="#func-price-single">calcula_precio_americana</a>
  <ul class="collapse">
  <li><a href="#recibe" id="toc-recibe" class="nav-link" data-scroll-target="#recibe">Recibe</a></li>
  <li><a href="#qué-hace-paso-a-paso" id="toc-qué-hace-paso-a-paso" class="nav-link" data-scroll-target="#qué-hace-paso-a-paso">Qué hace (paso a paso)</a></li>
  <li><a href="#devuelve" id="toc-devuelve" class="nav-link" data-scroll-target="#devuelve">Devuelve</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#simulación-correlacionada-2-activos-con-mu-histórica-p" id="toc-simulación-correlacionada-2-activos-con-mu-histórica-p" class="nav-link" data-scroll-target="#simulación-correlacionada-2-activos-con-mu-histórica-p">SIMULACIÓN CORRELACIONADA (2 activos) CON MU HISTÓRICA (P)</a>
  <ul class="collapse">
  <li><a href="#func-sim-corr" id="toc-func-sim-corr" class="nav-link" data-scroll-target="#func-sim-corr">genera_simulaciones_correlacionadas</a></li>
  <li><a href="#func-df-port" id="toc-func-df-port" class="nav-link" data-scroll-target="#func-df-port">genera_df_portafolio</a></li>
  </ul></li>
  <li><a href="#longstaffschwartz-portafolio" id="toc-longstaffschwartz-portafolio" class="nav-link" data-scroll-target="#longstaffschwartz-portafolio">LONGSTAFF–SCHWARTZ (PORTAFOLIO)</a>
  <ul class="collapse">
  <li><a href="#func-ls-port" id="toc-func-ls-port" class="nav-link" data-scroll-target="#func-ls-port">ejercicio_americana_LS_port</a>
  <ul class="collapse">
  <li><a href="#qué-hace-paso-a-paso-1" id="toc-qué-hace-paso-a-paso-1" class="nav-link" data-scroll-target="#qué-hace-paso-a-paso-1">Qué hace (paso a paso)</a></li>
  <li><a href="#devuelve-1" id="toc-devuelve-1" class="nav-link" data-scroll-target="#devuelve-1">Devuelve</a></li>
  </ul></li>
  <li><a href="#func-strategy-port" id="toc-func-strategy-port" class="nav-link" data-scroll-target="#func-strategy-port">obtiene_estrategia_LS_port</a></li>
  <li><a href="#func-price-port" id="toc-func-price-port" class="nav-link" data-scroll-target="#func-price-port">calcula_precio_americana_port</a></li>
  </ul></li>
  <li><a href="#binomial-americana-sola" id="toc-binomial-americana-sola" class="nav-link" data-scroll-target="#binomial-americana-sola">BINOMIAL AMERICANA (sola)</a>
  <ul class="collapse">
  <li><a href="#func-bin-single" id="toc-func-bin-single" class="nav-link" data-scroll-target="#func-bin-single">arbol_americano</a></li>
  <li><a href="#func-bin-port" id="toc-func-bin-port" class="nav-link" data-scroll-target="#func-bin-port">arbol_americano_portafolio</a>
  <ul class="collapse">
  <li><a href="#devuelve-2" id="toc-devuelve-2" class="nav-link" data-scroll-target="#devuelve-2">Devuelve</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#histograma" id="toc-histograma" class="nav-link" data-scroll-target="#histograma">HISTOGRAMA</a>
  <ul class="collapse">
  <li><a href="#func-hist" id="toc-func-hist" class="nav-link" data-scroll-target="#func-hist">plot_hist_ejercicio</a></li>
  </ul></li>
  <li><a href="#ejemplos-de-uso" id="toc-ejemplos-de-uso" class="nav-link" data-scroll-target="#ejemplos-de-uso">EJEMPLOS DE USO</a>
  <ul class="collapse">
  <li><a href="#sec-ejemplos" id="toc-sec-ejemplos" class="nav-link" data-scroll-target="#sec-ejemplos">Bloque principal <code>if __name__ == "__main__":</code></a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finanzas</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Eduardo Selim Martínez Mayorga </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 10, 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="finanzas" class="level1">
<h1>Finanzas</h1>
<section id="proyecto-individual" class="level2">
<h2 class="anchored" data-anchor-id="proyecto-individual">Proyecto individual</h2>
<section id="profesor-eduardo-selim-martínez-mayorga" class="level3">
<h3 class="anchored" data-anchor-id="profesor-eduardo-selim-martínez-mayorga">Profesor: Eduardo Selim Martínez Mayorga</h3>
</section>
</section>
<section id="diagrama-de-flujo-del-notebook-quarto" class="level2">
<h2 class="anchored" data-anchor-id="diagrama-de-flujo-del-notebook-quarto">Diagrama de flujo del notebook (Quarto)</h2>
<blockquote class="blockquote">
<p>Da click en una función para ir a su ficha (inputs → proceso → outputs).</p>
</blockquote>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB

  U["Inputs\n- ticker(s)\n- fechas\n- num_sims, dt_days, T_days\n- K, r, grados_pasado\n- (port) w\n- (binomial) T_years, N"]

  subgraph A["A) Datos + Estimadores"]
    A1[get_close]
    A2[returns_from_close]
    A3[ultimo_precio]
    A4[calcula_media]
    A5[calcula_desv_est]
    A6[calcula_correlacion]
  end

  subgraph B["B) Longstaff–Schwartz (1 activo)"]
    B1[genera_simulaciones_individual]
    B2[genera_df_simulaciones]
    B3[ejercicio_americana_LS]
    B4[obtiene_estrategia_LS]
    B5[calcula_precio_americana]
    B6[plot_hist_ejercicio]
  end

  subgraph C["C) Longstaff–Schwartz (Portafolio)"]
    C1[genera_simulaciones_correlacionadas]
    C2[genera_df_portafolio]
    C3[ejercicio_americana_LS_port]
    C4[obtiene_estrategia_LS_port]
    C5[calcula_precio_americana_port]
    C6[plot_hist_ejercicio]
  end

  subgraph D["D) Árbol Binomial (Americana)"]
    D1[arbol_americano]
    D2[arbol_americano_portafolio]
  end

  U --&gt; A1 --&gt; A2
  A1 --&gt; A3
  A2 --&gt; A4
  A2 --&gt; A5
  A2 --&gt; A6

  A3 --&gt; B1
  A4 --&gt; B1
  A5 --&gt; B1
  B1 --&gt; B2 --&gt; B3 --&gt; B4 --&gt; B5 --&gt; B6

  A6 --&gt; C1
  A4 --&gt; C1
  A5 --&gt; C1
  A3 --&gt; C1
  C1 --&gt; C2 --&gt; C3 --&gt; C4 --&gt; C5 --&gt; C6

  U --&gt; D1
  U --&gt; D2

  click A1 "#func-get-close" "Detalle: get_close"
  click A2 "#func-returns" "Detalle: returns_from_close"
  click A3 "#func-s0" "Detalle: ultimo_precio"
  click A4 "#func-mu" "Detalle: calcula_media"
  click A5 "#func-sigma" "Detalle: calcula_desv_est"
  click A6 "#func-rho" "Detalle: calcula_correlacion"

  click B1 "#func-sim-single" "Detalle: genera_simulaciones_individual"
  click B3 "#func-ls-single" "Detalle: ejercicio_americana_LS"
  click B5 "#func-price-single" "Detalle: calcula_precio_americana"

  click C1 "#func-sim-corr" "Detalle: genera_simulaciones_correlacionadas"
  click C3 "#func-ls-port" "Detalle: ejercicio_americana_LS_port"
  click C5 "#func-price-port" "Detalle: calcula_precio_americana_port"

  click D1 "#func-bin-single" "Detalle: arbol_americano"
  click D2 "#func-bin-port" "Detalle: arbol_americano_portafolio"
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<hr>
</section>
</section>
<section id="librerías" class="level1">
<h1>Librerías</h1>
<div id="de3eaccc" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yfinance <span class="im">as</span> yf</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PolynomialFeatures</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="3fb56707" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>TRADING_DAYS <span class="op">=</span> <span class="dv">252</span>  <span class="co"># días hábiles por año</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="descargar-datos-de-yahoo-finance" class="level1">
<h1>Descargar datos de Yahoo Finance</h1>
<section id="func-get-close" class="level2">
<h2 class="anchored" data-anchor-id="func-get-close">get_close</h2>
<p><strong>Recibe:</strong> <code>tickers</code>, <code>fecha_inicio</code>, <code>fecha_fin</code><br>
<strong>Hace:</strong> descarga precios de Yahoo Finance y devuelve un <code>DataFrame</code> con columnas=tickers.</p>
<div id="4c8c1908" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">@lru_cache</span>(maxsize<span class="op">=</span><span class="dv">128</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _download_close_cached(tickers_tuple, start, end, auto_adjust<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    tickers <span class="op">=</span> <span class="bu">list</span>(tickers_tuple)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> yf.download(</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        tickers,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        start<span class="op">=</span>start,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        end<span class="op">=</span>end,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        progress<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        auto_adjust<span class="op">=</span>auto_adjust,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        group_by<span class="op">=</span><span class="st">"column"</span>,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Caso MultiIndex</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(data.columns, pd.MultiIndex):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">"Close"</span> <span class="kw">in</span> data.columns.get_level_values(<span class="dv">0</span>):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            close <span class="op">=</span> data[<span class="st">"Close"</span>].copy()</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="st">"Adj Close"</span> <span class="kw">in</span> data.columns.get_level_values(<span class="dv">0</span>):</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            close <span class="op">=</span> data[<span class="st">"Adj Close"</span>].copy()</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">KeyError</span>(<span class="st">"No encontré 'Close' ni 'Adj Close' en columnas MultiIndex."</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Caso SingleIndex</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">"Close"</span> <span class="kw">in</span> data.columns:</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            close <span class="op">=</span> data[[<span class="st">"Close"</span>]].copy()</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="st">"Adj Close"</span> <span class="kw">in</span> data.columns:</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            close <span class="op">=</span> data[[<span class="st">"Adj Close"</span>]].copy()</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">KeyError</span>(<span class="st">"No encontré 'Close' ni 'Adj Close' en columnas."</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(tickers) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>            close.columns <span class="op">=</span> [tickers[<span class="dv">0</span>]]</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(close, pd.Series):</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        close <span class="op">=</span> close.to_frame(name<span class="op">=</span>tickers[<span class="dv">0</span>])</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> close.dropna(how<span class="op">=</span><span class="st">"all"</span>)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> close</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_close(tickers, fecha_inicio, fecha_fin, auto_adjust<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(tickers, <span class="bu">str</span>):</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        tickers <span class="op">=</span> [tickers]</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> _download_close_cached(<span class="bu">tuple</span>(tickers), fecha_inicio, fecha_fin, auto_adjust<span class="op">=</span>auto_adjust)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    missing <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> tickers <span class="cf">if</span> t <span class="kw">not</span> <span class="kw">in</span> close.columns]</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> missing:</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">KeyError</span>(<span class="ss">f"Faltan columnas para tickers: </span><span class="sc">{</span>missing<span class="sc">}</span><span class="ss">. Columnas disponibles: </span><span class="sc">{</span><span class="bu">list</span>(close.columns)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> close[tickers]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-returns" class="level2">
<h2 class="anchored" data-anchor-id="func-returns">returns_from_close</h2>
<p><strong>Recibe:</strong> <code>close: DataFrame</code><br>
<strong>Hace:</strong> calcula retornos log o simples.<br>
<strong>Devuelve:</strong> <code>DataFrame</code> de retornos.</p>
<div id="8e95880a" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> returns_from_close(close: pd.DataFrame, kind<span class="op">=</span><span class="st">"log"</span>):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> close.dropna(how<span class="op">=</span><span class="st">"any"</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> kind <span class="op">==</span> <span class="st">"log"</span>:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        rets <span class="op">=</span> np.log(close).diff()</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        rets <span class="op">=</span> close.pct_change()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rets.dropna(how<span class="op">=</span><span class="st">"any"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
<section id="estimadores" class="level1">
<h1>Estimadores</h1>
<section id="func-s0" class="level2">
<h2 class="anchored" data-anchor-id="func-s0">ultimo_precio</h2>
<p><strong>Recibe:</strong> - <code>ticker</code> (<code>str</code>): símbolo (ej. <code>"AAPL"</code>) - <code>fecha_inicio</code> (<code>str</code>): fecha inicio <code>"YYYY-MM-DD"</code> - <code>fecha_fin</code> (<code>str</code>): fecha fin <code>"YYYY-MM-DD"</code></p>
<p><strong>Qué hace:</strong> - Descarga la serie de precios de cierre (<code>Close</code> o <code>Adj Close</code>, según <code>get_close</code>) del ticker en el rango de fechas. - Toma el <strong>último valor disponible</strong> de la columna del ticker.</p>
<p><strong>Devuelve:</strong> - <code>float</code> con el último precio observado: <span class="math inline">\(S_0\)</span>.</p>
<div id="dc129b6c" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ultimo_precio(ticker, fecha_inicio, fecha_fin):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> get_close(ticker, fecha_inicio, fecha_fin)[ticker]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">float</span>(close.iloc[<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-mu" class="level2">
<h2 class="anchored" data-anchor-id="func-mu">calcula_media</h2>
<p><strong>Recibe:</strong> - ticker (str): símbolo (ej. “AAPL”) - <code>fecha_inicio</code> (<code>str</code>): fecha inicio <code>"YYYY-MM-DD"</code> - <code>fecha_fin</code> (<code>str</code>): fecha fin <code>"YYYY-MM-DD"</code> - <code>kind</code> (str, default “log”): tipo de retorno: <code>log</code>: <span class="math inline">\(r_t = \log(P_t) - \log(P_{t-1})\)</span></p>
<p><strong>Qué hace:</strong> - Descarga precios del activo en el rango. - Construye la serie de retornos diarios con <code>returns_from_close</code>. - Calcula la media muestral de esos retornos.</p>
<p><strong>Devuelve:</strong> - <code>float</code> con la media diaria: <span class="math inline">\(\mu_{\text{daily}} = \frac{1}{n}\sum_{t=1}^n r_t\)</span>.</p>
<div id="8094a580" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcula_media(ticker, fecha_inicio, fecha_fin, kind<span class="op">=</span><span class="st">"log"</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> get_close(ticker, fecha_inicio, fecha_fin)[ticker]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    rets <span class="op">=</span> returns_from_close(close.to_frame(<span class="st">"x"</span>), kind<span class="op">=</span>kind)[<span class="st">"x"</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">float</span>(rets.mean())  <span class="co"># media por día </span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-sigma" class="level2">
<h2 class="anchored" data-anchor-id="func-sigma">calcula_desv_est</h2>
<p><strong>Recibe:</strong> - ticker (str): símbolo (ej. “AAPL”) - <code>fecha_inicio</code> (<code>str</code>): fecha inicio <code>"YYYY-MM-DD"</code> - <code>fecha_fin</code> (<code>str</code>): fecha fin <code>"YYYY-MM-DD"</code> - <code>kind</code> (str, default “log”): tipo de retorno: <code>log</code>: <span class="math inline">\(r_t = \log(P_t) - \log(P_{t-1})\)</span> - <code>ddof</code> (int, default 1): grados de libertad para la desviación estándar: ddof=1 → muestral (recomendado para estimación) ddof=0 → “poblacional” (divide entre <span class="math inline">\(n\)</span>)</p>
<p><strong>Qué hace:</strong> - Descarga precios. - Calcula retornos diarios. - Calcula la desviación estándar de retornos (por default, muestral).</p>
<p><strong>Devuelve:</strong> - <code>float</code> con la volatilidad diaria estimada: <span class="math inline">\(\sigma_{\text{daily}}\)</span>.</p>
<div id="9b81791e" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcula_desv_est(ticker, fecha_inicio, fecha_fin, kind<span class="op">=</span><span class="st">"log"</span>, ddof<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> get_close(ticker, fecha_inicio, fecha_fin)[ticker]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    rets <span class="op">=</span> returns_from_close(close.to_frame(<span class="st">"x"</span>), kind<span class="op">=</span>kind)[<span class="st">"x"</span>]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">float</span>(rets.std(ddof<span class="op">=</span>ddof))  <span class="co"># sigma por día </span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-rho" class="level2">
<h2 class="anchored" data-anchor-id="func-rho">calcula_correlacion</h2>
<p><strong>Recibe:</strong> - ticker (str): símbolo (ej. “AAPL”) - <code>fecha_inicio</code> (<code>str</code>): fecha inicio <code>"YYYY-MM-DD"</code> - <code>fecha_fin</code> (<code>str</code>): fecha fin <code>"YYYY-MM-DD"</code> - <code>kind</code> (str, default “log”): tipo de retorno (log o simple)</p>
<p><strong>Qué hace:</strong> - Descarga precios de ambos tickers. - Construye retornos diarios alineados por fecha (esto es importante: correlación requiere observaciones pareadas). - Calcula la correlación muestral de Pearson entre las dos series de retornos.</p>
<p><strong>Devuelve:</strong> - <code>float</code> con la correlación: <span class="math inline">\(\rho \in [-1,1]\)</span>.</p>
<div id="489fc859" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcula_correlacion(ticker1, ticker2, fecha_inicio, fecha_fin, kind<span class="op">=</span><span class="st">"log"</span>):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> get_close([ticker1, ticker2], fecha_inicio, fecha_fin)[[ticker1, ticker2]]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    rets <span class="op">=</span> returns_from_close(close, kind<span class="op">=</span>kind)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">float</span>(rets.corr().iloc[<span class="dv">0</span>, <span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
<section id="payoffs-sin-globals" class="level1">
<h1>PAYOFFS (sin globals)</h1>
<div id="6dcc0e64" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> payoff_call(S, K):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(S <span class="op">-</span> K, <span class="fl">0.0</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> payoff_put(S, K):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(K <span class="op">-</span> S, <span class="fl">0.0</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="simulación-gbm-1-activo-con-mu-histórica-p" class="level1">
<h1>SIMULACIÓN GBM (1 activo) CON MU HISTÓRICA (P)</h1>
<p>El modelo buscamos simular es el movimiento browniano geométrico (GBM):</p>
<p>$ dS_t = S_t,dt + S_t,dW_t. $</p>
<p>La discretización para un paso de tamaño <span class="math inline">\(\Delta t\)</span> es:</p>
<p>$ S_{t+t} = S_t !( (- ^2)t + ,Z ), ZN(0,1). $</p>
<p>Por lo que tenemos dos factores indispensables: - El <strong>drift</strong> se multiplica por <span class="math inline">\(\Delta t\)</span>. - El <strong>término aleatorio</strong> (browniano) se multiplica por <span class="math inline">\(\sqrt{\Delta t}\)</span>.</p>
<p>En el código se construye <span class="math inline">\(W\)</span> como una suma acumulada de normales estándar, <span class="math inline">\(W=\sum Z\)</span>, y luego se usa $ S S_0( + W) $, lo cual equivale a asumir implícitamente <span class="math inline">\(\Delta t = 1\)</span> (un paso de “tamaño 1”) y además deja el parámetro <code>dt</code> sin afectar realmente la escala del proceso. Esto puede mezclar unidades (por ejemplo, interpretar <span class="math inline">\(T=252/2\)</span> como días mientras el proceso usa pasos de tamaño 1 sin conversion).</p>
<p>La corrección consiste en introducir explícitamente el tamaño del paso: si el paso es de <code>dt_days</code> días y se trabaja en años, entonces $ t = . $ Con esto, la simulación correcta usa: $ S_{k+1} = S_k !( (- ^2)t + ,Z_k ). $</p>
<p>Así, al cambiar <code>dt_days</code> o el horizonte <code>T_days</code>, el modelo se escala correctamente y las unidades de <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\sigma\)</span> y el descuento (por ejemplo con <span class="math inline">\(e^{-r\Delta t}\)</span>) quedan consistentes.</p>
<section id="func-sim-single" class="level2">
<h2 class="anchored" data-anchor-id="func-sim-single">genera_simulaciones_individual</h2>
<p>Simula GBM con <span class="math inline">\(\Delta t=\tfrac{dt\_days}{252}\)</span> y drift <span class="math inline">\(\mu\)</span> histórica.</p>
<p><strong>Recibe:</strong> - <code>ticker1</code> (<code>str</code>): símbolo del activo (ej. <code>"AAPL"</code>) - <code>fecha_inicio</code> (<code>str</code>): <code>"YYYY-MM-DD"</code> - <code>fecha_fin</code> (<code>str</code>): <code>"YYYY-MM-DD"</code> - <code>num_sims</code> (<code>int</code>): número de trayectorias simuladas - <code>dt_days</code> (<code>int | float</code>): tamaño del paso en <strong>días</strong> (ej. <code>1</code>) - <code>T_days</code> (<code>int | float</code>): horizonte total en <strong>días</strong> (ej. <code>252/2</code>) - <code>returns_kind</code> (<code>str</code>, default <code>"log"</code>): tipo de retorno usado para estimar <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma\)</span> - <code>seed</code> (<code>int | None</code>): semilla para reproducibilidad</p>
<p><strong>Qué hace:</strong> 1. Descarga precios con <code>get_close</code>. 2. Calcula retornos diarios con <code>returns_from_close</code>. 3. Estima parámetros históricos: - <span class="math inline">\(\mu_{daily} =\)</span> media diaria de retornos - <span class="math inline">\(\sigma_{daily} =\)</span> desv. estándar diaria (muestral, <code>ddof=1</code>) 4. Convierte a unidades anuales y define el paso en años: - <span class="math inline">\(\Delta t = dt\_days/252\)</span> 5. Genera una matriz de normales <span class="math inline">\(Z\)</span> de tamaño <code>(num_sims, steps)</code> y construye incrementos logarítmicos. 6. Acumula <span class="math inline">\(\log S\)</span> y regresa <span class="math inline">\(S\)</span> en niveles, incluyendo el valor inicial <span class="math inline">\(S_0\)</span>.</p>
<p><strong>Devuelve:</strong> - <code>numpy.ndarray</code> de tamaño <code>(num_sims, steps+1)</code>: - primera columna = <span class="math inline">\(S_0\)</span> - columnas siguientes = precios simulados en cada paso</p>
<div id="15ec7980" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> genera_simulaciones_individual(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Simula GBM con drift = mu histórica (medida P).</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - dt_days: paso en días (1 diario)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - T_days: horizonte total en días (ej. 252/2)</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Retorna array (num_sims, steps+1) incluyendo S0.</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    rng <span class="op">=</span> np.random.default_rng(seed)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> get_close(ticker1, fecha_inicio, fecha_fin)[ticker1]</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    rets <span class="op">=</span> returns_from_close(close.to_frame(<span class="st">"x"</span>), kind<span class="op">=</span>returns_kind)[<span class="st">"x"</span>]</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    mu_daily <span class="op">=</span> <span class="bu">float</span>(rets.mean())</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    sig_daily <span class="op">=</span> <span class="bu">float</span>(rets.std(ddof<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    S0 <span class="op">=</span> <span class="bu">float</span>(close.iloc[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> <span class="bu">int</span>(T_days <span class="op">/</span> dt_days)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> dt_days <span class="op">/</span> TRADING_DAYS  <span class="co"># años por paso</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Se anualiza para usar fórmula continua anual</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    mu_annual <span class="op">=</span> mu_daily <span class="op">*</span> TRADING_DAYS</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    sig_annual <span class="op">=</span> sig_daily <span class="op">*</span> np.sqrt(TRADING_DAYS)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> rng.normal(size<span class="op">=</span>(num_sims, steps))</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    inc <span class="op">=</span> (mu_annual <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sig_annual<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> dt <span class="op">+</span> sig_annual <span class="op">*</span> np.sqrt(dt) <span class="op">*</span> Z</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    logS <span class="op">=</span> np.log(S0) <span class="op">+</span> np.cumsum(inc, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.exp(logS)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.concatenate([np.full((num_sims, <span class="dv">1</span>), S0), S], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> genera_df_simulaciones(ticker1, fecha_inicio, fecha_fin, num_sims, dt_days, T_days,</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>                          returns_kind<span class="op">=</span><span class="st">"log"</span>, seed<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>    trayectorias <span class="op">=</span> genera_simulaciones_individual(</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>        ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>        returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> trayectorias.shape[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(trayectorias[:, <span class="dv">1</span>:])</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>    df.columns <span class="op">=</span> [<span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, steps <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
<section id="longstaffschwartz-1-activo" class="level1">
<h1>LONGSTAFF–SCHWARTZ (1 activo)</h1>
<p>En esta sección implementamos Longstaff–Schwartz (LS) para valuar (o aproximar) una opción Americana usando simulación Monte Carlo. La idea central es:</p>
<ol type="1">
<li>Simulas trayectorias <span class="math inline">\(S_{t}\)</span>.</li>
<li>Vas <strong>hacia atrás</strong> en el tiempo (backward induction).</li>
<li>En cada tiempo decides si conviene <strong>ejercer ahora</strong> (valor intrínseco) o <strong>continuar</strong> (valor esperado de seguir), donde el valor de continuación se aproxima con una regresión sobre el estado <span class="math inline">\(S_t\)</span>.</li>
</ol>
<p>En LS, en cada tiempo <span class="math inline">\(t\)</span> comparamos:</p>
<ul>
<li><strong>Intrínseco:</strong> <span class="math inline">\(g(S_t)\)</span> (payoff inmediato).</li>
<li><strong>Continuación:</strong> <span class="math inline">\(\mathbb{E}\left[e^{-r\Delta t}V_{t+\Delta t}\mid S_t\right]\)</span> (aproximado por regresión).</li>
</ul>
<p>Ejercemos si: $ g(S_t) (S_t). $</p>
<section id="func-ls-single" class="level2">
<h2 class="anchored" data-anchor-id="func-ls-single">ejercicio_americana_LS</h2>
<p><strong>Recibe:</strong> - <code>ticker1</code> (<code>str</code>), <code>fecha_inicio</code> (<code>str</code>), <code>fecha_fin</code> (<code>str</code>) - <code>num_sims</code> (<code>int</code>): número de trayectorias simuladas - <code>dt_days</code> (<code>int|float</code>): paso en días - <code>T_days</code> (<code>int|float</code>): horizonte total en días - <code>funcion_payoff</code> (<code>callable</code>): función vectorizada tipo <code>funcion_payoff(S, K)</code> que regresa payoff - <code>K</code> (<code>float</code>): strike - <code>grados_pasado</code> (<code>int</code>): grado del polinomio en la regresión (bases polinomiales) - <code>r</code> (<code>float</code>): tasa libre de riesgo anual (continua) - <code>returns_kind</code> (<code>str</code>): cómo se estiman retornos para simulación - <code>seed</code> (<code>int|None</code>): semilla aleatoria - <code>min_itm</code> (<code>int</code>): mínimo de puntos “in the money” para ajustar regresión (evita regresiones inestables)</p>
<p><strong>Qué hace:</strong> 1. <strong>Simula</strong> trayectorias y crea <code>df</code> con precios por paso (sin <span class="math inline">\(S_0\)</span>):<br>
<code>df</code> tiene tamaño <code>(num_sims, steps)</code> y columnas <code>"1"... "steps"</code>.</p>
<ol start="2" type="1">
<li><p>Convierte a <code>numpy</code> para mayor eficiencia: <code>paths = df.to_numpy()</code>.</p></li>
<li><p>Define el tamaño del paso en años: $ t = $<br>
y el factor de descuento por un paso: $ disc = e^{-rt}. $</p></li>
<li><p>Inicializa un indicador:</p>
<ul>
<li><code>alive[i] = True</code> significa que la trayectoria <code>i</code> <strong>aún no ha ejercido</strong>.</li>
<li>Si una trayectoria ejerce en algún tiempo, se marca <code>alive=False</code> para que ya no “vuelva a ejercer” después (porque una americana se ejerce una sola vez).</li>
</ul></li>
<li><p>Define <code>cf</code> (“cashflows”):</p>
<ul>
<li><code>cf[i]</code> representa el <strong>flujo que esa trayectoria recibiría</strong> si se mantiene la política óptima desde el tiempo actual hacia adelante.</li>
<li>Se inicia en el vencimiento con el payoff final: $ cf = g(S_T). $</li>
</ul></li>
<li><p>Recorre hacia atrás <code>t = steps-1 ... 1</code>:</p>
<ul>
<li>Descuenta el flujo futuro un paso: $ cf_{disc} = cf disc. $</li>
<li>Obtiene el estado en ese tiempo: $ S_t = paths[:, t-1]. $</li>
<li>Calcula intrínseco: $ intrinsic = g(S_t). $</li>
<li>Define elegibles para regresión:
<ul>
<li>Deben estar vivos (<code>alive=True</code>) y estar ITM (<code>intrinsic&gt;0</code>). Esto es estándar en LS: solo haces regresión con estados donde hay decisión real (si intrinsic=0 no hay incentivo a ejercer).</li>
</ul></li>
</ul></li>
<li><p>Si hay pocos elegibles (<code>eligible.sum() &lt; min_itm</code>):</p>
<ul>
<li>No ajusta regresión.</li>
<li>Solo avanza descontando: <code>cf = cf_disc</code>.</li>
<li>Guarda lista vacía de ejercicio en este tiempo.</li>
</ul></li>
<li><p>Si sí hay suficientes elegibles:</p>
<ul>
<li>Ajusta regresión para aproximar continuación:
<ul>
<li>Entradas <code>X = S_t[eligible]</code></li>
<li>Salidas <code>Y = cf_disc[eligible]</code></li>
<li>Bases polinomiales de grado <code>grados_pasado</code></li>
<li>Ajusta <code>LinearRegression</code> y predice: $ (S_t) $</li>
</ul></li>
<li>Decide ejercicio:
<ul>
<li><code>ex = intrinsic &gt;= cont</code></li>
</ul></li>
<li>Para los que ejercen:
<ul>
<li>Fija su cashflow a intrínseco: <code>cf[idx_ex] = intrinsic[idx_ex]</code></li>
<li>Los “mata” para tiempos anteriores: <code>alive[idx_ex] = False</code></li>
</ul></li>
</ul></li>
<li><p>Va guardando en <code>lst</code> los índices que ejercen en cada tiempo (en el orden en que corre hacia atrás).</p></li>
</ol>
<div id="27fa5d33" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ejercicio_americana_LS(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    funcion_payoff, K, grados_pasado,</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    r,</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    min_itm<span class="op">=</span><span class="dv">25</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Devuelve [lst, df] como tú.</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - df: sims x steps (sin S0) con columnas "1"... "steps"</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - lst: lista de listas de índices ejercidos (se arma hacia atrás como tu lógica)</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> genera_df_simulaciones(</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> df.shape[<span class="dv">1</span>]</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> dt_days <span class="op">/</span> TRADING_DAYS</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    disc <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> dt)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    paths <span class="op">=</span> df.to_numpy()</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    alive <span class="op">=</span> np.ones(num_sims, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># payoff al vencimiento</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    cf <span class="op">=</span> funcion_payoff(paths[:, <span class="op">-</span><span class="dv">1</span>], K).astype(<span class="bu">float</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    lst <span class="op">=</span> []</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    lst.append(np.where((cf <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">&amp;</span> alive)[<span class="dv">0</span>].tolist())</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># backward t = steps-1 ... 1</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(steps <span class="op">-</span> <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>        cf_disc <span class="op">=</span> cf <span class="op">*</span> disc</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>        S_t <span class="op">=</span> paths[:, t <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>        intrinsic <span class="op">=</span> funcion_payoff(S_t, K).astype(<span class="bu">float</span>)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>        eligible <span class="op">=</span> alive <span class="op">&amp;</span> (intrinsic <span class="op">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> eligible.<span class="bu">sum</span>() <span class="op">&lt;</span> min_itm:</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>            cf <span class="op">=</span> cf_disc</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>            lst.append([])</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> S_t[eligible].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>        Y <span class="op">=</span> cf_disc[eligible].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>        polin <span class="op">=</span> PolynomialFeatures(degree<span class="op">=</span>grados_pasado, include_bias<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>        Xp <span class="op">=</span> polin.fit_transform(X)</span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>        reg <span class="op">=</span> LinearRegression().fit(Xp, Y)</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>        cont <span class="op">=</span> reg.predict(Xp).flatten()</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>        ex <span class="op">=</span> intrinsic[eligible] <span class="op">&gt;=</span> cont</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>        idx_eligible <span class="op">=</span> np.where(eligible)[<span class="dv">0</span>]</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>        idx_ex <span class="op">=</span> idx_eligible[ex]</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>        cf <span class="op">=</span> cf_disc.copy()</span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>        cf[idx_ex] <span class="op">=</span> intrinsic[idx_ex]</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>        alive[idx_ex] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>        lst.append(idx_ex.tolist())</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [lst, df]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-strategy" class="level2">
<h2 class="anchored" data-anchor-id="func-strategy">obtiene_estrategia_LS</h2>
<p><strong>Recibe:</strong> - Los mismos parámetros que ejercicio_americana_LS, excepto <code>min_itm</code> (aquí no se usa). - Internamente llama a <code>ejercicio_americana_LS(...)</code>. <strong>Qué hace</strong></p>
<ol type="1">
<li><p>Obtiene <code>lst</code> y <code>df</code>.</p></li>
<li><p>Invierte <code>lst</code> para volverlo cronológico (de <span class="math inline">\(t=1\)</span> hacia <span class="math inline">\(t=steps\)</span>).</p></li>
<li><p>Construye una matriz binaria <code>df_estrategia</code> de tamaño <code>(num_sims, steps)</code>:</p>
<ul>
<li><code>df_estrategia[i, j] = 1</code> si la trayectoria <code>i</code> ejerció en el tiempo <code>j</code>.</li>
</ul></li>
<li><p>Para cada trayectoria i:</p></li>
</ol>
<ul>
<li><p>Si nunca ejerció, guarda <code>-1</code>.</p></li>
<li><p>Si ejerció, guarda el primer índice temporal donde aparece un <code>1</code>.</p></li>
</ul>
<p><strong>Devuelve:</strong> <code>[lista_fechas_ejercicio, df]</code> donde:</p>
<pre><code>- `lista_fechas_ejercicio[i]` es el primer tiempo donde la simulación i ejerce (o -1 si no ejerció).

- `df` son las trayectorias simuladas (sin $S_0$).</code></pre>
<div id="fa26e279" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> obtiene_estrategia_LS(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    funcion_payoff, K, grados_pasado,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    r,</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    lst, df <span class="op">=</span> ejercicio_americana_LS(</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        funcion_payoff, K, grados_pasado,</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        r<span class="op">=</span>r, returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    num_cols <span class="op">=</span> df.shape[<span class="dv">1</span>]</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    lst <span class="op">=</span> <span class="bu">list</span>(<span class="bu">reversed</span>(lst))  <span class="co"># orden temporal</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    df_estrategia <span class="op">=</span> np.zeros((num_sims, num_cols), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(num_cols):</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> lst[j] <span class="cf">if</span> j <span class="op">&lt;</span> <span class="bu">len</span>(lst) <span class="cf">else</span> []</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> idx:</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            df_estrategia[idx, j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    lista_fechas_ejercicio <span class="op">=</span> []</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_sims):</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> df_estrategia[i, :]</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> row.<span class="bu">sum</span>() <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>            lista_fechas_ejercicio.append(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>            lista_fechas_ejercicio.append(<span class="bu">int</span>(np.argmax(row)))</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [lista_fechas_ejercicio, df]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-price-single" class="level2">
<h2 class="anchored" data-anchor-id="func-price-single">calcula_precio_americana</h2>
<p>Esta función toma la <strong>política de ejercicio</strong> que encontró Longstaff–Schwartz (LS) y la convierte en un <strong>precio</strong>: el promedio del payoff descontado al tiempo de ejercicio de cada trayectoria.</p>
<hr>
<section id="recibe" class="level3">
<h3 class="anchored" data-anchor-id="recibe">Recibe</h3>
<ul>
<li><code>ticker1</code> (<code>str</code>), <code>fecha_inicio</code> (<code>str</code>), <code>fecha_fin</code> (<code>str</code>)</li>
<li><code>num_sims</code> (<code>int</code>): número de simulaciones</li>
<li><code>dt_days</code> (<code>int|float</code>): tamaño del paso en <strong>días</strong></li>
<li><code>T_days</code> (<code>int|float</code>): horizonte total en <strong>días</strong></li>
<li><code>funcion_payoff</code> (<code>callable</code>): payoff vectorizado o escalar, tipo <code>funcion_payoff(S, K)</code></li>
<li><code>K</code> (<code>float</code>): strike</li>
<li><code>grados_pasado</code> (<code>int</code>): grado del polinomio para la regresión en LS</li>
<li><code>r</code> (<code>float</code>): tasa libre de riesgo anual (continua)</li>
<li><code>returns_kind</code> (<code>str</code>): tipo de retorno (log o simple) usado para simulación</li>
<li><code>seed</code> (<code>int|None</code>): semilla para reproducibilidad</li>
</ul>
<hr>
</section>
<section id="qué-hace-paso-a-paso" class="level3">
<h3 class="anchored" data-anchor-id="qué-hace-paso-a-paso">Qué hace (paso a paso)</h3>
<ol type="1">
<li><p>Llama a <code>obtiene_estrategia_LS(...)</code> para obtener:</p>
<ul>
<li><code>lista_fechas_ejercicio</code>: lista con el <strong>primer tiempo</strong> (índice) donde cada trayectoria ejercería, o <code>-1</code> si no ejerció.</li>
<li><code>df</code>: <code>DataFrame</code> con trayectorias simuladas (sin <span class="math inline">\(S_0\)</span>), con columnas <code>"1"... "steps"</code>.</li>
</ul></li>
<li><p>Convierte el paso a años: <span class="math display">\[
\Delta t = \frac{dt\_days}{252}.
\]</span></p></li>
<li><p>Para cada trayectoria <code>i</code>:</p>
<ul>
<li>Si <code>t_idx &lt; 0</code> (nunca ejerció), asigna payoff 0.</li>
<li>Si sí ejerció:
<ul>
<li>Toma el precio simulado en el tiempo de ejercicio:<br>
<code>S_ex = df.iloc[i, t_idx]</code></li>
<li>Calcula payoff inmediato <code>funcion_payoff(S_ex, K)</code></li>
<li>Lo descuenta a valor presente con descuento continuo: <span class="math display">\[
PV_i = g(S_{t_i})\exp(-r \, t_i \Delta t).
\]</span></li>
</ul></li>
</ul>
<p><strong>Ojo con</strong> <code>(t_idx + 1)</code>:</p>
<ul>
<li>En <code>df</code>, la columna <code>"1"</code> representa el <strong>primer paso</strong> después de <span class="math inline">\(S_0\)</span>.<br>
</li>
<li>Pero <code>t_idx</code> es un índice base 0 (Python):
<ul>
<li><code>t_idx = 0</code> corresponde a tiempo <strong>1 paso</strong>.<br>
</li>
</ul></li>
<li>Por eso el tiempo real en pasos es <code>(t_idx + 1)</code>.</li>
</ul></li>
<li><p>Construye <code>estrategia_ejercicio</code> para graficar:</p>
<ul>
<li>Convierte <code>-1</code> a <code>NaN</code> (para que el histograma ignore “no ejerció”).</li>
<li>Mantiene el índice <code>t</code> si sí ejerció.</li>
</ul></li>
</ol>
<hr>
</section>
<section id="devuelve" class="level3">
<h3 class="anchored" data-anchor-id="devuelve">Devuelve</h3>
<ul>
<li><code>[precio, estrategia_ejercicio]</code> donde:
<ul>
<li><code>precio</code> (<code>float</code>) = promedio de los payoffs descontados: <span class="math display">\[
\hat{V}_0 = \frac{1}{N}\sum_{i=1}^N PV_i
\]</span></li>
<li><code>estrategia_ejercicio</code> (<code>list[float]</code>) = lista de índices de ejercicio (o <code>NaN</code> si no ejerció), útil para histograma.</li>
</ul></li>
</ul>
<hr>
<div id="722d9ce5" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcula_precio_americana(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    funcion_payoff, K, grados_pasado,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    r,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    lista_fechas_ejercicio, df <span class="op">=</span> obtiene_estrategia_LS(</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        funcion_payoff, K, grados_pasado,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        r<span class="op">=</span>r, returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> dt_days <span class="op">/</span> TRADING_DAYS</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    payoff_ejercicio <span class="op">=</span> np.zeros(num_sims, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_sims):</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        t_idx <span class="op">=</span> lista_fechas_ejercicio[i]</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t_idx <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>            payoff_ejercicio[i] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>            S_ex <span class="op">=</span> <span class="bu">float</span>(df.iloc[i, t_idx])</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>            payoff_ejercicio[i] <span class="op">=</span> <span class="bu">float</span>(funcion_payoff(S_ex, K)) <span class="op">*</span> math.exp(<span class="op">-</span>r <span class="op">*</span> (t_idx <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dt)</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    estrategia_ejercicio <span class="op">=</span> [np.nan <span class="cf">if</span> t <span class="op">&lt;</span> <span class="dv">0</span> <span class="cf">else</span> t <span class="cf">for</span> t <span class="kw">in</span> lista_fechas_ejercicio]</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="bu">float</span>(np.mean(payoff_ejercicio)), estrategia_ejercicio]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
</section>
<section id="simulación-correlacionada-2-activos-con-mu-histórica-p" class="level1">
<h1>SIMULACIÓN CORRELACIONADA (2 activos) CON MU HISTÓRICA (P)</h1>
<p>Aquí simulamos dos activos <span class="math inline">\((S_t^{(1)}, S_t^{(2)})\)</span> bajo GBM <strong>correlacionados</strong>, usando parámetros históricos (medida <span class="math inline">\(P\)</span>):</p>
<p>[ dS_t^{(1)}=_1 S_t^{(1)}dt + _1 S_t^{(1)} dW_t^{(1)}, dS_t^{(2)}=_2 S_t^{(2)}dt + _2 S_t^{(2)} dW_t^{(2)}, ] con correlación instantánea [ (dW_t^{(1)}, dW_t^{(2)})=. ]</p>
<hr>
<section id="func-sim-corr" class="level2">
<h2 class="anchored" data-anchor-id="func-sim-corr">genera_simulaciones_correlacionadas</h2>
<p><strong>Recibe:</strong> - <code>ticker1</code> (<code>str</code>), <code>ticker2</code> (<code>str</code>) - <code>fecha_inicio</code> (<code>str</code>), <code>fecha_fin</code> (<code>str</code>) - <code>num_sims</code> (<code>int</code>): número de trayectorias - <code>dt_days</code> (<code>int|float</code>): paso en días - <code>T_days</code> (<code>int|float</code>): horizonte en días - <code>returns_kind</code> (<code>str</code>, default <code>"log"</code>): retornos para estimar <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma\)</span> - <code>seed</code> (<code>int|None</code>): semilla para reproducibilidad</p>
<p><strong>Qué hace (paso a paso):</strong> 1. Descarga precios de ambos activos y calcula retornos diarios alineados: - Estima <span class="math inline">\(\mu_{1,daily}, \sigma_{1,daily}, \mu_{2,daily}, \sigma_{2,daily}\)</span>. - Estima <span class="math inline">\(\rho\)</span> como correlación muestral de retornos.</p>
<ol start="2" type="1">
<li><p>Define valores iniciales: [ S_{0,1}=, S_{0,2}=. ]</p></li>
<li><p>Define unidades (igual que en 1 activo): [ t = , <em>{annual}=252,</em>{daily}, <em>{annual}=,</em>{daily}. ]</p></li>
<li><p>Construye la correlación con <strong>Cholesky</strong>:</p>
<ul>
<li>Matriz de correlación objetivo: [ C=
<span class="math display">\[\begin{pmatrix}1 &amp; \rho\\ \rho &amp; 1\end{pmatrix}\]</span>
]</li>
<li>Factor de Cholesky <span class="math inline">\(L\)</span> tal que <span class="math inline">\(C = LL^\top\)</span>.</li>
</ul></li>
<li><p>Genera normales iid:</p>
<ul>
<li><code>Z ~ N(0, I)</code> con forma <code>(num_sims, steps, 2)</code>.</li>
</ul></li>
<li><p>Obtiene normales correlacionadas:</p>
<ul>
<li><code>EZ = Z @ L.T</code><br>
entonces cada par <span class="math inline">\((EZ_1, EZ_2)\)</span> tiene correlación <span class="math inline">\(\rho\)</span>.</li>
</ul></li>
<li><p>Simula incrementos logarítmicos (GBM exacto): [ S^{(i)} = (_i - _i^2)t + _i, _i, ] donde <span class="math inline">\((\varepsilon_1,\varepsilon_2)\)</span> son las normales correlacionadas.</p></li>
<li><p>Construye <span class="math inline">\(S_1, S_2\)</span> acumulando y exponenciando, e inserta la columna inicial <span class="math inline">\(S_0\)</span> al principio.</p></li>
</ol>
<p><strong>Devuelve:</strong> - <code>[S1, S2]</code> donde: - <code>S1</code>: <code>np.ndarray</code> de tamaño <code>(num_sims, steps+1)</code> con <span class="math inline">\(S_{0,1}\)</span> incluido. - <code>S2</code>: <code>np.ndarray</code> de tamaño <code>(num_sims, steps+1)</code> con <span class="math inline">\(S_{0,2}\)</span> incluido.</p>
<div id="cb9030b2" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> genera_simulaciones_correlacionadas(</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    ticker1, ticker2,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    fecha_inicio, fecha_fin,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    rng <span class="op">=</span> np.random.default_rng(seed)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    close <span class="op">=</span> get_close([ticker1, ticker2], fecha_inicio, fecha_fin)[[ticker1, ticker2]]</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    rets <span class="op">=</span> returns_from_close(close, kind<span class="op">=</span>returns_kind)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    mu1_daily <span class="op">=</span> <span class="bu">float</span>(rets[ticker1].mean())<span class="op">;</span> sig1_daily <span class="op">=</span> <span class="bu">float</span>(rets[ticker1].std(ddof<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    mu2_daily <span class="op">=</span> <span class="bu">float</span>(rets[ticker2].mean())<span class="op">;</span> sig2_daily <span class="op">=</span> <span class="bu">float</span>(rets[ticker2].std(ddof<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> <span class="bu">float</span>(rets.corr().iloc[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    S01 <span class="op">=</span> <span class="bu">float</span>(close[ticker1].iloc[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    S02 <span class="op">=</span> <span class="bu">float</span>(close[ticker2].iloc[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> <span class="bu">int</span>(T_days <span class="op">/</span> dt_days)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> dt_days <span class="op">/</span> TRADING_DAYS</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    mu1_annual <span class="op">=</span> mu1_daily <span class="op">*</span> TRADING_DAYS</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    mu2_annual <span class="op">=</span> mu2_daily <span class="op">*</span> TRADING_DAYS</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    sig1_annual <span class="op">=</span> sig1_daily <span class="op">*</span> np.sqrt(TRADING_DAYS)</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    sig2_annual <span class="op">=</span> sig2_daily <span class="op">*</span> np.sqrt(TRADING_DAYS)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> np.array([[<span class="fl">1.0</span>, rho], [rho, <span class="fl">1.0</span>]])</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> np.linalg.cholesky(C)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> rng.normal(size<span class="op">=</span>(num_sims, steps, <span class="dv">2</span>))</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    EZ <span class="op">=</span> Z <span class="op">@</span> L.T</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    inc1 <span class="op">=</span> (mu1_annual <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sig1_annual<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> dt <span class="op">+</span> sig1_annual <span class="op">*</span> np.sqrt(dt) <span class="op">*</span> EZ[:, :, <span class="dv">0</span>]</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    inc2 <span class="op">=</span> (mu2_annual <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sig2_annual<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> dt <span class="op">+</span> sig2_annual <span class="op">*</span> np.sqrt(dt) <span class="op">*</span> EZ[:, :, <span class="dv">1</span>]</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>    S1 <span class="op">=</span> np.exp(np.log(S01) <span class="op">+</span> np.cumsum(inc1, axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>    S2 <span class="op">=</span> np.exp(np.log(S02) <span class="op">+</span> np.cumsum(inc2, axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>    S1 <span class="op">=</span> np.concatenate([np.full((num_sims, <span class="dv">1</span>), S01), S1], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>    S2 <span class="op">=</span> np.concatenate([np.full((num_sims, <span class="dv">1</span>), S02), S2], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [S1, S2]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-df-port" class="level2">
<h2 class="anchored" data-anchor-id="func-df-port">genera_df_portafolio</h2>
<p>Esta función construye el portafolio: <span class="math inline">\(P_t = wS^{(1)}_{t} + (1-w)S^{(2)}_{t}\)</span></p>
<p><strong>Recibe:</strong></p>
<ul>
<li><p><code>w</code>(<code>float</code>): peso del activo 1 (el del activo 2 es 1-w)</p></li>
<li><p><code>ticker1</code>, <code>ticker2</code>, <code>fecha_inicio</code>, <code>fecha_fin</code></p></li>
<li><p><code>num_sims</code>, <code>dt_days</code>, <code>T_days</code></p></li>
<li><p><code>returns_kind</code>, <code>seed</code></p></li>
</ul>
<p><strong>Qué hace:</strong></p>
<ol type="1">
<li><p>Llama <code>genera_simulaciones_correlacionadas(...)</code> y obtiene <code>[S1, S2]</code>.</p></li>
<li><p>Construye el portafolio en niveles para cada trayectoria y tiempo:</p>
<ul>
<li>P = w<em>S1 + (1-w)</em>S2</li>
</ul></li>
<li><p>Elimina la columna inicial (<span class="math inline">\(P_0\)</span>) para que el formato coincida con LS:</p>
<ul>
<li>Devuelve solo pasos <code>"1"... "steps"</code>.</li>
</ul></li>
</ol>
<p><strong>Devuelve:</strong> <code>DataFrame (num_sims, steps)</code> con precios del portafolio simulados (sin <span class="math inline">\(P_0\)</span>), columnas <code>"1"... "steps"</code>.</p>
<div id="2a56d2e8" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> genera_df_portafolio(</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    w, ticker1, ticker2,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    fecha_inicio, fecha_fin,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    S1, S2 <span class="op">=</span> genera_simulaciones_correlacionadas(</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        ticker1, ticker2,</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        fecha_inicio, fecha_fin,</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> w <span class="op">*</span> S1 <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> S2</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> P.shape[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(P[:, <span class="dv">1</span>:])</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    df.columns <span class="op">=</span> [<span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, steps <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
<section id="longstaffschwartz-portafolio" class="level1">
<h1>LONGSTAFF–SCHWARTZ (PORTAFOLIO)</h1>
<p>Aquí aplicamos Longstaff–Schwartz (LS) a una opción Americana cuyo subyacente es un <strong>portafolio</strong>:</p>
<p>[ P_t = w S_t^{(1)} + (1-w) S_t^{(2)}. ]</p>
<p>La lógica del algoritmo es la misma que en 1 activo: en cada tiempo comparamos el valor intrínseco inmediato (g(P_t)) contra el valor de continuación ((P_t)) estimado por regresión.</p>
<hr>
<section id="func-ls-port" class="level2">
<h2 class="anchored" data-anchor-id="func-ls-port">ejercicio_americana_LS_port</h2>
<p><strong>Recibe:</strong> - <code>w</code> (<code>float</code>): peso del activo 1 (activo 2 usa <code>1-w</code>) - <code>ticker1</code> (<code>str</code>), <code>ticker2</code> (<code>str</code>) - <code>fecha_inicio</code> (<code>str</code>), <code>fecha_fin</code> (<code>str</code>) - <code>num_sims</code> (<code>int</code>): número de trayectorias simuladas - <code>dt_days</code> (<code>int|float</code>): paso en días - <code>T_days</code> (<code>int|float</code>): horizonte en días - <code>funcion_payoff</code> (<code>callable</code>): payoff sobre <strong>portafolio</strong>, tipo <code>funcion_payoff(P, K)</code> - <code>K</code> (<code>float</code>): strike (en unidades del portafolio) - <code>grados_pasado</code> (<code>int</code>): grado del polinomio para regresión LS - <code>r</code> (<code>float</code>): tasa libre de riesgo anual (continua) - <code>returns_kind</code> (<code>str</code>, default <code>"log"</code>): retornos usados para estimar (,,) en la simulación - <code>seed</code> (<code>int|None</code>): semilla - <code>min_itm</code> (<code>int</code>): mínimo de puntos ITM para ajustar regresión</p>
<hr>
<section id="qué-hace-paso-a-paso-1" class="level3">
<h3 class="anchored" data-anchor-id="qué-hace-paso-a-paso-1">Qué hace (paso a paso)</h3>
<ol type="1">
<li><p>Construye trayectorias del <strong>portafolio</strong> en un <code>DataFrame</code>:</p>
<ul>
<li>Llama a <code>genera_df_portafolio(...)</code></li>
<li>Obtiene <code>df</code> tamaño <code>(num_sims, steps)</code> con columnas <code>"1"... "steps"</code>.</li>
<li>Nota: <code>df</code> ya contiene (P_t), o sea <strong>el subyacente</strong> que usa LS.</li>
</ul></li>
<li><p>Define unidades: [ t = , disc = e^{-rt}. ]</p></li>
<li><p>Convierte <code>df</code> a numpy: <code>paths = df.to_numpy()</code>.</p></li>
<li><p>Controla ejercicio único por trayectoria con:</p>
<ul>
<li><code>alive[i]=True</code> si la trayectoria <code>i</code> <strong>aún no ha ejercido</strong>.</li>
<li>si ejerce en algún tiempo, se marca <code>False</code> para no “ejercer dos veces”.</li>
</ul></li>
<li><p>Inicializa los cashflows al vencimiento: [ cf_i = g(P_T^{(i)}). ]</p></li>
<li><p>Recorre hacia atrás <code>t = steps-1 ... 1</code>:</p>
<ul>
<li>Descuenta un paso: <code>cf_disc = cf * disc</code></li>
<li>Estado actual del portafolio: <code>S_t = paths[:, t-1]</code> (aquí <code>S_t</code> es realmente (P_t))</li>
<li>Valor intrínseco: <code>intrinsic = g(P_t)</code></li>
<li>Elegibles para regresión: <code>eligible = alive &amp; (intrinsic &gt; 0)</code></li>
</ul></li>
<li><p>Si hay pocos elegibles (<code>eligible.sum() &lt; min_itm</code>):</p>
<ul>
<li>No ajusta regresión, solo actualiza <code>cf = cf_disc</code></li>
<li>Guarda lista vacía de ejercicio.</li>
</ul></li>
<li><p>Si hay suficientes elegibles:</p>
<ul>
<li>Ajusta regresión polinomial para estimar continuación:
<ul>
<li><code>X = P_t</code> (solo de elegibles)</li>
<li><code>Y = cf_disc</code> (solo de elegibles)</li>
<li>Predice continuación ((P_t))</li>
</ul></li>
<li>Decide ejercicio si: [ g(P_t) (P_t). ]</li>
<li>Para los que ejercen:
<ul>
<li>fija <code>cf</code> a intrínseco</li>
<li>marca <code>alive=False</code> para no volver a ejercer</li>
</ul></li>
</ul></li>
<li><p>Guarda en <code>lst</code> los índices que ejercen en cada tiempo (se arma hacia atrás).</p></li>
</ol>
<hr>
</section>
<section id="devuelve-1" class="level3">
<h3 class="anchored" data-anchor-id="devuelve-1">Devuelve</h3>
<ul>
<li><code>[lst, df]</code> donde:
<ul>
<li><code>df</code>: trayectorias simuladas del portafolio (P_t), tamaño <code>(num_sims, steps)</code>.</li>
<li><code>lst</code>: lista de listas de índices de trayectorias que ejercen por tiempo (construida hacia atrás).</li>
</ul></li>
</ul>
<div id="a5fc4f54" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ejercicio_americana_LS_port(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    w, ticker1, ticker2,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    fecha_inicio, fecha_fin,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    funcion_payoff, K, grados_pasado,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    r,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    min_itm<span class="op">=</span><span class="dv">25</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> genera_df_portafolio(</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        w, ticker1, ticker2,</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        fecha_inicio, fecha_fin,</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> df.shape[<span class="dv">1</span>]</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> dt_days <span class="op">/</span> TRADING_DAYS</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    disc <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> dt)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    paths <span class="op">=</span> df.to_numpy()</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    alive <span class="op">=</span> np.ones(num_sims, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    cf <span class="op">=</span> funcion_payoff(paths[:, <span class="op">-</span><span class="dv">1</span>], K).astype(<span class="bu">float</span>)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    lst <span class="op">=</span> []</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    lst.append(np.where((cf <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">&amp;</span> alive)[<span class="dv">0</span>].tolist())</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(steps <span class="op">-</span> <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>        cf_disc <span class="op">=</span> cf <span class="op">*</span> disc</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>        S_t <span class="op">=</span> paths[:, t <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>        intrinsic <span class="op">=</span> funcion_payoff(S_t, K).astype(<span class="bu">float</span>)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>        eligible <span class="op">=</span> alive <span class="op">&amp;</span> (intrinsic <span class="op">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> eligible.<span class="bu">sum</span>() <span class="op">&lt;</span> min_itm:</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>            cf <span class="op">=</span> cf_disc</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>            lst.append([])</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> S_t[eligible].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>        Y <span class="op">=</span> cf_disc[eligible].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>        polin <span class="op">=</span> PolynomialFeatures(degree<span class="op">=</span>grados_pasado, include_bias<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>        Xp <span class="op">=</span> polin.fit_transform(X)</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>        reg <span class="op">=</span> LinearRegression().fit(Xp, Y)</span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>        cont <span class="op">=</span> reg.predict(Xp).flatten()</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>        ex <span class="op">=</span> intrinsic[eligible] <span class="op">&gt;=</span> cont</span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>        idx_eligible <span class="op">=</span> np.where(eligible)[<span class="dv">0</span>]</span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>        idx_ex <span class="op">=</span> idx_eligible[ex]</span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>        cf <span class="op">=</span> cf_disc.copy()</span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>        cf[idx_ex] <span class="op">=</span> intrinsic[idx_ex]</span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>        alive[idx_ex] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a>        lst.append(idx_ex.tolist())</span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [lst, df]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
<section id="func-strategy-port" class="level2">
<h2 class="anchored" data-anchor-id="func-strategy-port">obtiene_estrategia_LS_port</h2>
<p><strong>Recibe:</strong> Los mismos parámetros que <code>ejercicio_americana_LS_port(...)</code> (sin <code>min_itm</code> explícito).</p>
<p><strong>Qué hace:</strong></p>
<ol type="1">
<li><p>Llama <code>ejercicio_americana_LS_port(...)</code> y obtiene <code>lst</code> y <code>df</code>.</p></li>
<li><p>Invierte <code>lst</code> para volverlo cronológico.</p></li>
<li><p>Construye una matriz binaria <code>df_estrategia</code> (sims × steps) con 1 en el tiempo donde ejerció.</p></li>
<li><p>Para cada trayectoria:</p>
<ul>
<li><p>si nunca ejerció, guarda <code>-1</code></p></li>
<li><p>si ejerció, guarda el primer tiempo donde ejerció (índice temporal)</p></li>
</ul></li>
</ol>
<p><strong>Devuelve:</strong></p>
<p><code>[lista_fechas_ejercicio, df]</code> donde:</p>
<ul>
<li><p><code>lista_fechas_ejercicio[i]</code> = tiempo (índice) de ejercicio de la trayectoria <code>i</code> o <code>-1</code>.</p></li>
<li><p><code>df</code> = trayectorias del portafolio <span class="math inline">\(P_t\)</span> ​</p></li>
</ul>
<div id="d5f0d525" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> obtiene_estrategia_LS_port(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    w, ticker1, ticker2,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    fecha_inicio, fecha_fin,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    funcion_payoff, K, grados_pasado,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    r,</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    lst, df <span class="op">=</span> ejercicio_americana_LS_port(</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        w, ticker1, ticker2,</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        fecha_inicio, fecha_fin,</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        funcion_payoff, K, grados_pasado,</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        r<span class="op">=</span>r, returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    num_cols <span class="op">=</span> df.shape[<span class="dv">1</span>]</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    lst <span class="op">=</span> <span class="bu">list</span>(<span class="bu">reversed</span>(lst))</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    df_estrategia <span class="op">=</span> np.zeros((num_sims, num_cols), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(num_cols):</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> lst[j] <span class="cf">if</span> j <span class="op">&lt;</span> <span class="bu">len</span>(lst) <span class="cf">else</span> []</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> idx:</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>            df_estrategia[idx, j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    lista_fechas_ejercicio <span class="op">=</span> []</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_sims):</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> df_estrategia[i, :]</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> row.<span class="bu">sum</span>() <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>            lista_fechas_ejercicio.append(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>            lista_fechas_ejercicio.append(<span class="bu">int</span>(np.argmax(row)))</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [lista_fechas_ejercicio, df]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-price-port" class="level2">
<h2 class="anchored" data-anchor-id="func-price-port">calcula_precio_americana_port</h2>
<p>Esta función convierte la <strong>estrategia de ejercicio</strong> hallada por Longstaff–Schwartz en un <strong>precio</strong> para la opción Americana cuyo subyacente es el portafolio:</p>
<p>[ P_t = wS_t^{(1)} + (1-w)S_t^{(2)}. ]</p>
<p>El precio se estima como el promedio del payoff <strong>descontado</strong> al tiempo de ejercicio de cada trayectoria.</p>
<hr>
<p><strong>Recibe:</strong> - <code>w</code> (<code>float</code>): peso del activo 1 (activo 2 usa <code>1-w</code>) - <code>ticker1</code> (<code>str</code>), <code>ticker2</code> (<code>str</code>) - <code>fecha_inicio</code> (<code>str</code>), <code>fecha_fin</code> (<code>str</code>) - <code>num_sims</code> (<code>int</code>): número de trayectorias simuladas - <code>dt_days</code> (<code>int|float</code>): paso en días - <code>T_days</code> (<code>int|float</code>): horizonte en días - <code>funcion_payoff</code> (<code>callable</code>): payoff sobre el portafolio, tipo <code>funcion_payoff(P, K)</code> - <code>K</code> (<code>float</code>): strike (en unidades del portafolio) - <code>grados_pasado</code> (<code>int</code>): grado del polinomio usado dentro de LS - <code>r</code> (<code>float</code>): tasa libre de riesgo anual (continua) - <code>returns_kind</code> (<code>str</code>, default <code>"log"</code>) - <code>seed</code> (<code>int|None</code>)</p>
<hr>
<p><strong>Qué hace:</strong> 1. Llama a <code>obtiene_estrategia_LS_port(...)</code> para obtener: - <code>lista_fechas_ejercicio</code>: primer tiempo de ejercicio por trayectoria (o <code>-1</code> si no ejerció). - <code>df</code>: trayectorias simuladas del <strong>portafolio</strong> (P_t) (sin (P_0)), con columnas <code>"1"... "steps"</code>.</p>
<ol start="2" type="1">
<li><p>Convierte el paso a años: [ t = . ]</p></li>
<li><p>Para cada trayectoria <code>i</code>:</p>
<ul>
<li>Si <code>t_idx &lt; 0</code>, asigna payoff 0 (no ejerció en ningún tiempo).</li>
<li>Si sí ejerció:
<ul>
<li>Toma el precio del portafolio en el tiempo de ejercicio: [ P_{ex} = df[i, t_idx] ]</li>
<li>Evalúa payoff inmediato (g(P_{ex})).</li>
<li>Descuenta a valor presente: [ PV_i = g(P_{ex})!(-r,(t_{pasos})t), ] donde (t_{pasos} = t_idx + 1).</li>
</ul></li>
</ul>
<p><strong>Ojo con</strong> <code>(t_idx + 1)</code>:</p>
<ul>
<li><code>t_idx=0</code> corresponde al primer paso (columna <code>"1"</code>), o sea <strong>1 paso</strong> después de (P_0).</li>
<li>Por eso el tiempo real en pasos es <code>t_idx + 1</code>.</li>
</ul></li>
<li><p>Construye <code>estrategia_ejercicio</code> para graficar histograma:</p>
<ul>
<li>Reemplaza <code>-1</code> por <code>NaN</code>, así el histograma ignora trayectorias que no ejercieron.</li>
</ul></li>
</ol>
<hr>
<p><strong>Devuelve</strong></p>
<ul>
<li><code>[precio_port, estrategia_ejercicio]</code> donde:
<ul>
<li><code>precio_port</code> (<code>float</code>) = promedio de los payoffs descontados: [ <em>0 = </em>{i=1}^N PV_i ]</li>
<li><code>estrategia_ejercicio</code> (<code>list[float]</code>) = tiempos de ejercicio (índice) o <code>NaN</code> si no ejerció.</li>
</ul></li>
</ul>
<div id="ef9f0930" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcula_precio_americana_port(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    w, ticker1, ticker2,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    fecha_inicio, fecha_fin,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    num_sims, dt_days, T_days,</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    funcion_payoff, K, grados_pasado,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    r,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    returns_kind<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="va">None</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    lista_fechas_ejercicio, df <span class="op">=</span> obtiene_estrategia_LS_port(</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        w, ticker1, ticker2,</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        fecha_inicio, fecha_fin,</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        num_sims, dt_days, T_days,</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        funcion_payoff, K, grados_pasado,</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        r<span class="op">=</span>r, returns_kind<span class="op">=</span>returns_kind, seed<span class="op">=</span>seed</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> dt_days <span class="op">/</span> TRADING_DAYS</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    payoff_ejercicio <span class="op">=</span> np.zeros(num_sims, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_sims):</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>        t_idx <span class="op">=</span> lista_fechas_ejercicio[i]</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t_idx <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>            payoff_ejercicio[i] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>            S_ex <span class="op">=</span> <span class="bu">float</span>(df.iloc[i, t_idx])</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>            payoff_ejercicio[i] <span class="op">=</span> <span class="bu">float</span>(funcion_payoff(S_ex, K)) <span class="op">*</span> math.exp(<span class="op">-</span>r <span class="op">*</span> (t_idx <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dt)</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>    estrategia_ejercicio <span class="op">=</span> [np.nan <span class="cf">if</span> t <span class="op">&lt;</span> <span class="dv">0</span> <span class="cf">else</span> t <span class="cf">for</span> t <span class="kw">in</span> lista_fechas_ejercicio]</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="bu">float</span>(np.mean(payoff_ejercicio)), estrategia_ejercicio]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
<section id="binomial-americana-sola" class="level1">
<h1>BINOMIAL AMERICANA (sola)</h1>
<p>En esta sección valuamos una opción <strong>Americana</strong> con un <strong>árbol binomial</strong> de (N) pasos.<br>
A diferencia del GBM con () histórica (medida (P)), en el árbol binomial para valuación se trabaja con la <strong>medida neutral al riesgo</strong> (risk-neutral): el drift relevante para el precio es (r), no ().</p>
<hr>
<section id="func-bin-single" class="level2">
<h2 class="anchored" data-anchor-id="func-bin-single">arbol_americano</h2>
<p><strong>Recibe:</strong> - <code>ticker</code> (<code>str</code>): símbolo del activo (ej. <code>"AAPL"</code>) - <code>fecha_inicio</code> (<code>str</code>), <code>fecha_fin</code> (<code>str</code>): ventana histórica para estimar () - <code>K</code> (<code>float</code>): strike - <code>T_years</code> (<code>float</code>): madurez en <strong>años</strong> (ej. <code>1.0</code>) - <code>r</code> (<code>float</code>): tasa libre de riesgo anual (continua) - <code>N</code> (<code>int</code>): número de pasos del árbol - <code>tipo</code> (<code>str</code>): <code>"call"</code> o <code>"put"</code> - <code>returns_kind</code> (<code>str</code>, default <code>"log"</code>): tipo de retorno para estimar ()</p>
<hr>
<p><strong>Qué hace</strong> 1. <strong>Estima volatilidad diaria</strong> (<em>{daily}) desde retornos históricos con <code>calcula_desv_est(...)</code><br>
y la convierte a <strong>anual</strong>: [ = </em>{daily}. ]</p>
<ol start="2" type="1">
<li><p>Define el tamaño del paso en años: [ t = . ]</p></li>
<li><p>Define factores de subida y bajada (modelo tipo CRR): [ u = e^{}, d=. ]</p></li>
<li><p>Define la probabilidad neutral al riesgo: [ p = , ] y el factor de descuento por paso: [ disc = e^{-rt}. ]</p></li>
<li><p>Obtiene el precio inicial (S_0) como el último precio histórico en el rango.</p></li>
<li><p>Construye los precios al vencimiento (S_T(j)) para (j=0,,N): [ S_T(j)=S_0,u<sup>j,d</sup>{N-j}. ]</p></li>
<li><p>Evalúa el payoff al vencimiento: [ V_T(j)=(S_T(j)-K,0) &nbsp;, V_T(j)=(K-S_T(j),0) &nbsp;. ]</p></li>
<li><p>Hace <strong>backward induction</strong> desde (i=N-1) hasta (0):</p>
<ul>
<li>Valor por continuación (risk-neutral): [ V^{cont} = disc,[pV<sup>{up}+(1-p)V</sup>{down}]. ]</li>
<li>Valor por ejercicio inmediato (Americana): [ V^{ex} = (S_i-K,0) &nbsp;, (K-S_i,0)&nbsp;. ]</li>
<li>Toma: [ V_i = (V^{cont}, V^{ex}). ] Esto es lo que hace que sea <strong>Americana</strong>: permite ejercicio temprano.</li>
</ul></li>
</ol>
<hr>
<p><strong>Devuelve</strong> - <code>float</code>: valor de la opción en el nodo inicial, (V_0).</p>
<div id="85faff72" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> arbol_americano(ticker, fecha_inicio, fecha_fin, K, T_years, r, N, tipo<span class="op">=</span><span class="st">"put"</span>,</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>                   returns_kind<span class="op">=</span><span class="st">"log"</span>):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    sigma_daily <span class="op">=</span> calcula_desv_est(ticker, fecha_inicio, fecha_fin, kind<span class="op">=</span>returns_kind, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> sigma_daily <span class="op">*</span> np.sqrt(TRADING_DAYS)  <span class="co"># anual</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T_years <span class="op">/</span> N</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.exp(sigma <span class="op">*</span> np.sqrt(dt))</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> u</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> (np.exp(r <span class="op">*</span> dt) <span class="op">-</span> d) <span class="op">/</span> (u <span class="op">-</span> d)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    disc <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> dt)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    S0 <span class="op">=</span> ultimo_precio(ticker, fecha_inicio, fecha_fin)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> np.arange(N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    S_T <span class="op">=</span> S0 <span class="op">*</span> (u <span class="op">**</span> j) <span class="op">*</span> (d <span class="op">**</span> (N <span class="op">-</span> j))</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> np.maximum(S_T <span class="op">-</span> K, <span class="fl">0.0</span>) <span class="cf">if</span> tipo <span class="op">==</span> <span class="st">"call"</span> <span class="cf">else</span> np.maximum(K <span class="op">-</span> S_T, <span class="fl">0.0</span>)</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> np.arange(i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        S_i <span class="op">=</span> S0 <span class="op">*</span> (u <span class="op">**</span> j) <span class="op">*</span> (d <span class="op">**</span> (i <span class="op">-</span> j))</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> disc <span class="op">*</span> (p <span class="op">*</span> V[<span class="dv">1</span>:] <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> p) <span class="op">*</span> V[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> np.maximum(V, S_i <span class="op">-</span> K) <span class="cf">if</span> tipo <span class="op">==</span> <span class="st">"call"</span> <span class="cf">else</span> np.maximum(V, K <span class="op">-</span> S_i)</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">float</span>(V[<span class="dv">0</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="func-bin-port" class="level2">
<h2 class="anchored" data-anchor-id="func-bin-port">arbol_americano_portafolio</h2>
<p>En esta función valuamos una opción Americana con árbol binomial, pero cuyo resultado es el <strong>portafolio</strong>:</p>
<p>[ P = wS^{(1)} + (1-w)S^{(2)}. ]</p>
<p>La idea del código es: tratar al portafolio como si fuera “un solo activo” binomial con volatilidad anual (_P) estimada con:</p>
<p>[ _P^2 = w^2_1^2 + (1-w)^2_2^2 + 2w(1-w)_1_2. ]</p>
<hr>
<p><strong>Recibe</strong> - <code>ticker1</code> (<code>str</code>), <code>ticker2</code> (<code>str</code>) - <code>w</code> (<code>float</code>): peso del activo 1 (activo 2 tiene <code>1-w</code>) - <code>fecha_inicio</code> (<code>str</code>), <code>fecha_fin</code> (<code>str</code>): ventana histórica para estimar (_1,_2,) - <code>K</code> (<code>float</code>): strike (en unidades del portafolio) - <code>T_years</code> (<code>float</code>): madurez en <strong>años</strong> - <code>r</code> (<code>float</code>): tasa libre de riesgo anual (continua) - <code>N</code> (<code>int</code>): número de pasos del árbol - <code>tipo</code> (<code>str</code>): <code>"call"</code> o <code>"put"</code> - <code>returns_kind</code> (<code>str</code>, default <code>"log"</code>): tipo de retornos para estimación</p>
<hr>
<p><strong>Qué hace</strong> 1. Estima volatilidades diarias de ambos activos y anualiza: [ <em>1 = </em>{1,daily}, <em>2 = </em>{2,daily}. ]</p>
<ol start="2" type="1">
<li><p>Estima la correlación histórica de retornos: [ = Corr(r^{(1)}, r^{(2)}). ]</p></li>
<li><p>Calcula la volatilidad anual del portafolio: [ _P = . ]</p></li>
<li><p>Construye el árbol binomial con (N) pasos y horizonte (T): [ t = , u = e^{_P}, d = . ]</p></li>
<li><p>Calcula probabilidad neutral al riesgo y descuento: [ p = , disc = e^{-rt}. ]</p></li>
<li><p>Define el valor inicial del portafolio con últimos precios: [ P_0 = wS_{0,1} + (1-w)S_{0,2}. ]</p></li>
<li><p>Calcula valores al vencimiento: [ P_T(j)=P_0u^j d^{N-j}, j=0,,N, ] y payoff: [ V_T(j)=(P_T(j)-K,0)&nbsp;,(K-P_T(j),0)&nbsp;. ]</p></li>
<li><p>Backward induction (Americana):</p>
<ul>
<li>Continuación: [ V^{cont} = disc,[pV<sup>{up}+(1-p)V</sup>{down}]. ]</li>
<li>Ejercicio inmediato: [ V^{ex}=(P_i-K,0)&nbsp; (K-P_i,0)&nbsp;. ]</li>
<li>Nodo: [ V_i = (V^{cont}, V^{ex}). ]</li>
</ul></li>
</ol>
<hr>
<section id="devuelve-2" class="level3">
<h3 class="anchored" data-anchor-id="devuelve-2">Devuelve</h3>
<ul>
<li><code>float</code>: valor aproximado en el nodo inicial (V_0) del derivado americano sobre el portafolio.</li>
</ul>
<div id="c60cbb19" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> arbol_americano_portafolio(ticker1, ticker2, w, fecha_inicio, fecha_fin, K, T_years, r, N,</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                               tipo<span class="op">=</span><span class="st">"call"</span>, returns_kind<span class="op">=</span><span class="st">"log"</span>):</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    sig1_daily <span class="op">=</span> calcula_desv_est(ticker1, fecha_inicio, fecha_fin, kind<span class="op">=</span>returns_kind, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    sig2_daily <span class="op">=</span> calcula_desv_est(ticker2, fecha_inicio, fecha_fin, kind<span class="op">=</span>returns_kind, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    sig1 <span class="op">=</span> sig1_daily <span class="op">*</span> np.sqrt(TRADING_DAYS)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    sig2 <span class="op">=</span> sig2_daily <span class="op">*</span> np.sqrt(TRADING_DAYS)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> calcula_correlacion(ticker1, ticker2, fecha_inicio, fecha_fin, kind<span class="op">=</span>returns_kind)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    sigmaP <span class="op">=</span> math.sqrt((w<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> (sig1<span class="op">**</span><span class="dv">2</span>) <span class="op">+</span> ((<span class="dv">1</span><span class="op">-</span>w)<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> (sig2<span class="op">**</span><span class="dv">2</span>) <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>w<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>w)<span class="op">*</span>rho<span class="op">*</span>sig1<span class="op">*</span>sig2)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T_years <span class="op">/</span> N</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.exp(sigmaP <span class="op">*</span> np.sqrt(dt))</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> u</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> (np.exp(r <span class="op">*</span> dt) <span class="op">-</span> d) <span class="op">/</span> (u <span class="op">-</span> d)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    disc <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> dt)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    S01 <span class="op">=</span> ultimo_precio(ticker1, fecha_inicio, fecha_fin)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    S02 <span class="op">=</span> ultimo_precio(ticker2, fecha_inicio, fecha_fin)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    S0 <span class="op">=</span> w <span class="op">*</span> S01 <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> S02</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> np.arange(N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    S_T <span class="op">=</span> S0 <span class="op">*</span> (u <span class="op">**</span> j) <span class="op">*</span> (d <span class="op">**</span> (N <span class="op">-</span> j))</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> np.maximum(S_T <span class="op">-</span> K, <span class="fl">0.0</span>) <span class="cf">if</span> tipo <span class="op">==</span> <span class="st">"call"</span> <span class="cf">else</span> np.maximum(K <span class="op">-</span> S_T, <span class="fl">0.0</span>)</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> np.arange(i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        S_i <span class="op">=</span> S0 <span class="op">*</span> (u <span class="op">**</span> j) <span class="op">*</span> (d <span class="op">**</span> (i <span class="op">-</span> j))</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> disc <span class="op">*</span> (p <span class="op">*</span> V[<span class="dv">1</span>:] <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> p) <span class="op">*</span> V[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> np.maximum(V, S_i <span class="op">-</span> K) <span class="cf">if</span> tipo <span class="op">==</span> <span class="st">"call"</span> <span class="cf">else</span> np.maximum(V, K <span class="op">-</span> S_i)</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">float</span>(V[<span class="dv">0</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<hr>
</section>
</section>
</section>
<section id="histograma" class="level1">
<h1>HISTOGRAMA</h1>
<p>Este bloque sirve para visualizar cuando se ejercen las opciones según la estrategia estimada por Longstaff–Schwartz.</p>
<section id="func-hist" class="level2">
<h2 class="anchored" data-anchor-id="func-hist">plot_hist_ejercicio</h2>
<p><strong>Recibe:</strong> - <code>estrategia_ejercicio</code> (<code>list[float]</code> o <code>list[int]</code>): - Lista con el índice de ejercicio por simulación. - Usualmente viene de <code>calcula_precio_americana(...)</code> o <code>calcula_precio_americana_port(...)</code>. - Contiene <code>NaN</code> para trayectorias que <strong>no ejercieron</strong> (eso se hace a propósito para graficar). - <code>T_days</code> (<code>int|float</code>): horizonte total en días (ej. <code>252/2</code>) - <code>titulo</code> (<code>str</code>): título del histograma</p>
<p><strong>Qué hace:</strong> 1. Convierte la lista a <code>numpy</code> y separa valores válidos: - <code>valid = ej[~np.isnan(ej)]</code> elimina los <code>NaN</code> (trayectorias que no ejercieron). 2. Dibuja el histograma de los índices de ejercicio. 3. En el título muestra cuántas simulaciones no ejercieron.</p>
<p><strong>Devuelve:</strong> - No devuelve nada (<code>None</code>). Solo <strong>grafica</strong>.</p>
<div id="519c15c0" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_hist_ejercicio(estrategia_ejercicio, T_days, titulo<span class="op">=</span><span class="st">"Histograma ejercicio"</span>):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    ej <span class="op">=</span> np.array(estrategia_ejercicio, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    valid <span class="op">=</span> ej[<span class="op">~</span>np.isnan(ej)]</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    plt.figure()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    plt.hist(valid, bins<span class="op">=</span><span class="bu">max</span>(<span class="dv">10</span>, <span class="bu">int</span>(T_days <span class="op">/</span> <span class="dv">2</span>)))</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"</span><span class="sc">{</span>titulo<span class="sc">}</span><span class="ss"> | no ejerció: </span><span class="sc">{</span>np<span class="sc">.</span>isnan(ej)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Índice de tiempo "</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Frecuencia"</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p><strong>Interpretación del eje X:</strong> - El histograma muestra el <strong>índice de tiempo</strong> <code>t_idx</code> (base 0) donde ejerció cada trayectoria. - Para convertirlo a: - <strong>pasos reales</strong>: <code>t_steps = t_idx + 1</code> - <strong>días</strong>: <code>t_days ≈ (t_idx + 1) * dt_days</code> (si usas <code>dt_days=1</code>, coincide con días) - <strong>años</strong>: <code>t_years = (t_idx + 1) * dt_days / 252</code></p>
</section>
</section>
<section id="ejemplos-de-uso" class="level1">
<h1>EJEMPLOS DE USO</h1>
<p>Esta sección sirve como guia del notebook: fija parámetros, ejecuta las funciones principales y muestra resultados (precios + histogramas).</p>
<hr>
<section id="sec-ejemplos" class="level2">
<h2 class="anchored" data-anchor-id="sec-ejemplos">Bloque principal <code>if __name__ == "__main__":</code></h2>
<p><strong>Qué define (inputs):</strong> - <code>ticker1</code>, <code>ticker2</code>: activos (ej. <code>"AAPL"</code>, <code>"SBUX"</code>) - <code>fecha_inicio</code>, <code>fecha_fin</code>: ventana histórica para estimar (), () y () - <code>r</code>: tasa libre de riesgo anual (continua), usada para descuento y para binomial - <code>dt_days</code>: tamaño del paso en días (1 = diario) - <code>T_days</code>: horizonte total en días (ej. <code>252/2</code>) - <code>num_sims</code>: número de simulaciones (Monte Carlo) - <code>grados_pasado</code>: grado del polinomio en LS (regresión para continuación)</p>
<p><strong>Qué hace:</strong> 1. Define un strike para LS en el caso single: - <code>K = ultimo_precio(ticker1, ...)</code><br>
(esto replica tu idea: strike “razonable” cercano al spot actual).</p>
<ol start="2" type="1">
<li>Ejecuta Longstaff–Schwartz (1 activo, put):
<ul>
<li>Llama <code>calcula_precio_americana(...)</code></li>
<li>Imprime el precio estimado</li>
<li>Grafica el histograma de tiempos/índices de ejercicio con <code>plot_hist_ejercicio(...)</code></li>
</ul></li>
<li>Ejecuta Longstaff–Schwartz (portafolio, put):
<ul>
<li>Define <code>w</code> (peso del activo 1)</li>
<li>Construye strike del portafolio: [ K_p = wS_{0,1} + (1-w)S_{0,2} ]</li>
<li>Llama <code>calcula_precio_americana_port(...)</code></li>
<li>Imprime el precio estimado</li>
<li>Grafica histograma del ejercicio</li>
</ul></li>
<li>Ejecuta árbol binomial (1 activo, call):
<ul>
<li>Llama <code>arbol_americano(...)</code></li>
<li>Imprime el precio binomial</li>
</ul></li>
<li>Ejecuta árbol binomial (portafolio, call):
<ul>
<li>Usa un strike ejemplo (promedio simple de spots): [ K = ]</li>
<li>Llama <code>arbol_americano_portafolio(...)</code></li>
<li>Imprime el precio binomial del portafolio (aprox)</li>
</ul></li>
</ol>
<p><strong>Devuelve:</strong> - Este bloque no “devuelve” como función; produce <strong>salida en consola</strong> (prints) y <strong>gráficas</strong> (histogramas).</p>
<hr>
<div id="1a96ec1b" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    ticker1 <span class="op">=</span> <span class="st">"AAPL"</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    ticker2 <span class="op">=</span> <span class="st">"SBUX"</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    fecha_inicio <span class="op">=</span> <span class="st">"2021-01-01"</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    fecha_fin <span class="op">=</span> <span class="st">"2022-03-31"</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="fl">0.06</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    dt_days <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    T_days <span class="op">=</span> <span class="dv">252</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    num_sims <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    grados_pasado <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># strike ejemplo como tú</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> ultimo_precio(ticker1, fecha_inicio, fecha_fin)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- LS single (simulación con mu histórica) ---</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    precio, ejercicios <span class="op">=</span> calcula_precio_americana(</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>        ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>        num_sims<span class="op">=</span>num_sims, dt_days<span class="op">=</span>dt_days, T_days<span class="op">=</span>T_days,</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>        funcion_payoff<span class="op">=</span>payoff_put, K<span class="op">=</span>K, grados_pasado<span class="op">=</span>grados_pasado,</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        r<span class="op">=</span>r, seed<span class="op">=</span><span class="dv">123</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Precio LS (single, put, con mu):"</span>, precio)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    plot_hist_ejercicio(ejercicios, T_days, <span class="st">"Ejercicio (single)"</span>)</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- LS portafolio (simulación con mu histórica) ---</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> <span class="fl">0.7</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    K1 <span class="op">=</span> ultimo_precio(ticker1, fecha_inicio, fecha_fin)</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>    K2 <span class="op">=</span> ultimo_precio(ticker2, fecha_inicio, fecha_fin)</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>    Kp <span class="op">=</span> w <span class="op">*</span> K1 <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> K2</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>    precio_p, ejercicios_p <span class="op">=</span> calcula_precio_americana_port(</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>        w, ticker1, ticker2,</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>        fecha_inicio, fecha_fin,</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>        num_sims<span class="op">=</span>num_sims, dt_days<span class="op">=</span>dt_days, T_days<span class="op">=</span>T_days,</span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>        funcion_payoff<span class="op">=</span>payoff_put, K<span class="op">=</span>Kp, grados_pasado<span class="op">=</span>grados_pasado,</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>        r<span class="op">=</span>r, seed<span class="op">=</span><span class="dv">123</span></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Precio LS (port, put, con mu):"</span>, precio_p)</span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>    plot_hist_ejercicio(ejercicios_p, T_days, <span class="st">"Ejercicio (portafolio)"</span>)</span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Binomial sola ---</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>    precio_bin <span class="op">=</span> arbol_americano(</span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>        ticker1, fecha_inicio, fecha_fin,</span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>        K<span class="op">=</span><span class="dv">170</span>, T_years<span class="op">=</span><span class="fl">1.0</span>, r<span class="op">=</span>r, N<span class="op">=</span><span class="dv">100</span>, tipo<span class="op">=</span><span class="st">"call"</span></span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Precio Binomial (single, call):"</span>, precio_bin)</span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Binomial port ---</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>    K_port_bin <span class="op">=</span> (K1 <span class="op">+</span> K2) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>    precio_bin_port <span class="op">=</span> arbol_americano_portafolio(</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>        ticker1, ticker2, w, fecha_inicio, fecha_fin,</span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>        K<span class="op">=</span>K_port_bin, T_years<span class="op">=</span><span class="fl">1.0</span>, r<span class="op">=</span>r, N<span class="op">=</span><span class="dv">100</span>, tipo<span class="op">=</span><span class="st">"call"</span></span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Precio Binomial (port, call):"</span>, precio_bin_port)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Precio LS (single, put, con mu): 5.784533171961813</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="finanzas_interactivo_files/figure-html/cell-23-output-2.png" width="602" height="453" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Precio LS (port, put, con mu): 5.024894322103897</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="finanzas_interactivo_files/figure-html/cell-23-output-4.png" width="601" height="453" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Precio Binomial (single, call): 25.408051141006418
Precio Binomial (port, call): 29.098881896232083</code></pre>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>